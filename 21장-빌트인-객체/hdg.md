# 21장 빌트인 객체

> 자바스크립트의 내장 객체와 전역 객체에 대해 설명하는 장 입니다.

## 21,1 자바스크립트 객체의 분류

- 자바스크립트 객체는 다음과 같이 크게 3개의 객체로 분류할 수 있다.

1. 표준 빌트인 객체 (standard built-in objects, native objects, global objects)
2. 호스트 객체 (host objects)
3. 사용자 정의 객체 (user—defined objects)

- 표준 빌트인 객체는 ECMAScript 사양에 정의된 객체를 말한다. 실행 환경(브라우저, Node.js)과 관계없이 언제나 사용할 수 있다.

- 호스트 객체는 ECMAScript 사양은 아니지만 실행환경에서 추가로 제겅하는 객체다. (DOM, Web Worker)

- 사용자 정의 객체는 사용자가 직접 정의한 객체를 말한다.

> 오늘은 표준 빌트인 객체에 대해서 이야기 한다.

## 21.2 표준 빌트인 객체

- 자바스크립트는 Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Promise, Reflect, Proxy, JSON. Error 등 40여 개의 표준 빌트인 객체를 제공한다.

- Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다.

- 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드, 정적 메서드를 제공한다.

- 생성자 아닌 객체는 정적 메서드만 제공한다.

> 예제 21-01

- 생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼
  티에 바인딩된 객체다.
- 예를 들어, 표준 빌트인 객체인 String을 생성자 함수로서 호출하여 생성한 String 인스턴스의 프로토타입은 String.prototype이다.

> 【예제 21-02 】

> 이 부분이 가장 어려웠던 문장인데, 프로토타입을 다시 읽어보니 그냥 생성자 함수로 만들어진 인스턴스가 생성자 함수의 프로퍼티인 프로토타입 객체를 상속받았다는 이야기다.

> 299 페이지 298페이지 이미지 12

```js
// Number 생성자 함수에 의한 Number 객체 생성
const numObj = new Number(1.5); // Number {1.5}

// toFixed는 Number.prototype의 프로토타입 메서드다.
// Number.prototype.toFixed는 소수점 자리를 반올림하여 문자열로 반환한다
console.log(numObj.toFixed()); // 2

// islnteger는 Number의 정적 메서드다.
// Number.islnteger는 인수가 정수(integer)인시 검사하여 그 결과를 Boolean으로 반환한다
console.log(Number.islnteger(0.5)); // false
```

> 위 예제는 인스턴스 numObj가 프로토타입을 상속받아 메서드를 사용할 수 있는것과, Number자체가 제공하는 정적 메서드사용을 보여준다.

## 21.3 원시값과 래퍼 객체

- 문자열이나 숫자, 불리언 등의 원시값이 있는데도 문자열, 숫자, 불리언 객체를 생성하는 String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재하는 이유는 무엇일까?

> 예제 21-04

- 위 예제를 보면 원시값인 문자열이 객체처럼 작동한다.

- 원시값인 문자열, 숫자, 불리언 값의 경우 마침표(.)로 접근하면 js엔진이 암죽적으로 연관된 객체를 생성해 프로퍼티, 메서드에 접근하고 다시 원시값으로 되돌린다.

- 이처럼 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체(wrapper object)라 한다.

> 【예제 21-05 】

- 위 예제에서 str.length 처럼 문자열이 마침표로 접근하면 래퍼객체가 싸이고 문자열은 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.

- 그리고 String.prototype의 메서드를 사용한 후 다시 원래 원시값으로 되돌린다.

- 래퍼객체는 가비지 컬랙터의 대상이 된다.

> 【예제 21-07

> 숫자도 불리언도 마찬가지

> 심벌은 다른 원시값과는 차이가 있는데 자세한 내용은 33장에서

- 이처럼 문자열, 숫자, 불리언, 심벌은 암묵적으로 래퍼 객체에 의해 객체처럼 사용할 수 있어서 굳이 new 연산자와 함께 생성자 함수를 호출해 생성할 필요가 없고, 권장하지 않음

- null과 undefined는 래퍼 객체를 생성하지 않는다.

## 21.4 전역 객체

- 전역 객체(Global Object)는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체다.

- 브라우저 환경에서는 window, nodejs환경에서는 global이 전역객체를 가리킨다.

> this, self, frames도 가리킴

> 예제 globalThis 이미지

> 【예제 21-08 】

> globalThis는 ECMAScript 표준사양을 준수하는 환경에서 전역객체를 가리키는 통합된 식별자다. (window, global 다 가리킴)

- 전역 객체는 위의 표준 빌트인 객체와 호스트객체(Web API등) var로 선언한 전역 변수와 전역함수를 프로퍼티로 가진다.

> 조금 해깔렸던 부분인데 아래서도 나오는데 var 키워드는 함수 스코프다. 함수 안에 지역변수 말고 밖에 전역변수로 var를 쓰면 전역 객체 프로퍼티가 된다. const, let은 안됨

> 또 나오지만 암묵적 전역변수도 전역객체 프로퍼티가 됨

> 【예제 21-10 】

- 전역객체가 최상위 객체라는건 프로토타입 상속 관계에서 최상위라는 의미는 아니다. 이건 표준 빌트인 객체 중 Object 객체

- 전역 객체는 다음 특징이 있음

1. 전역객체는 개발자가 의도적으로 생성할 수 없다. 즉 생성자 함수가 없음

2. 전역객체 프로퍼티를 참조할때 window(또는 global)를 생략할 수 있음

- 이번에는 전역객체의 프로퍼티와 메서드를 살펴본다. window나 global생략해 참조,호출 할 수 있기 때문에 전역 변수,함수처럼 쓸 수 있다.

### 21.4.1 빌트인 전역 프로퍼티

- Infinity
- NaN
- undefined

- 빌트인 전역 프로퍼티(built-in global property)는 전역 객체의 프로퍼티를 의미하며, 애플리케이션 전역에서 사용하는 값을 제공한다.

> 【예제 21-12 】
> 【예제 21-13 ]
> 【예제 21-14

> Infinity, NaN 는 숫자타입 원시값, undefined는 undefined타입 원시값인데 무슨 이야기인지 했는데, 전역 객체에 같은 이름의 프포퍼티들이 있고 그 안에 원시값들이 또 있다. 전역객체가 해당값들을 자주써서 바로 접근할려고 있다는거 같음.

### 21.4.2 빌트인 전역 함수

- eval
- isFinite
- isNaN
- parseFloat
- parselnt
- encodelURI / decodelURI
- encodeURIComponent / decodelURIComponent

#### eval

> 할까 말까 하다가 처음 아는게 많아서 작성해봄. 쓰지는 말자.

- js 코드를 나타내는 문자열을 인수로 받는다. 표현식이면 런타임에 값을 생성하고, 문이면 해당 코드를 런타임에 실행한다.

```js
eval("1 +2; 3+4;"); // 7
```

```js
const x = 1;

function foo() {
  // eval 함수는 런타임에 foo 함수의 스코프를 동적으로 수정한다
  eval('var x = 2;');
  console.log(x); // 2
}

foo()；

console.log(x); // 1
```

> 값을 생성하는걸 런타임에 하는건 당연한건데, 위 예제처럼 var 변수 선언이 런타임에 실행된다. 런타임에 함수의 스코프를 동적으로 수정한다.

- strict mode에서는 eval이 함수 스코프를 동적으로 수정하지 않고 자체적인 스코프를 생성한다.

- 또한 let, const 키워드를 사용한 변수 선언문이면 암묵적으로 strict mode가 적용된다.

> 【예제 21-19 ]

> eval은 보안에 취약하고 js엔진에 의해 최적화가 수행되지 않으니 사용을 금지하자.

#### isFinite

- 인수가 유한수면 true, 무한수면 false를 반환

> 【예제 21-20 】 와 그 위 코드

#### isNaN

- 인수가 NaN인지 검사해 불리언을 반환

> 예제 21-22 ]

#### parseFloat

- 전달받은 문자열 인수를 부동 소수점 숫자(floating point number), 즉 실수로 해석하여 반환한다.

> [ 예제 21-23 】

> 아래서 더 많이 설명하지만 숫자 문자열타입(Numeric String)을 숫자(number)로 변환해 준다.

#### parselnt

- parseFloat 처럼 전달받은 문자열을 정수로 해석한다.

> 【예제 21-24 】

- 문자열이 아니면(정수, 불리언 등) 문자열로 변환 후 정수로 해석 한다.

> [ 예제 21-25 】

- 두번째 인수로 진법을 나타내는 기수를 전달해 n진수로 해석해 반환할 수 있다.

> 【예제 21-26 】

- 참고로 정수를 n진수 문자열로 변환하고 싶을때는 Number.prototype. toString 메서드 사용

> parselnt : 문자열 -> 정수 , toString : 정수 -> 문자열

> 【예제 21-27 】

```js
// 16진수 리터럴 '0xf'를 16진수로 해석하고 10진수 정수로 그 결과를 반환한다.
parseInt(0xf); // → 15
// 위 코드와 같다.
parseInt("f", 16); // → 15

// 2진수 리터럴(0b로 시작)
parseInt("0b10"); // → 0  // '0' 이후가 무시된다.

// 8진수 리터럴(ES6에서 도입, 0o로 시작)
parseInt("0o10"); // → 0  // '0' 이후가 무시된다.
```

> 무시되는 이유는 parseInt가 0 이후의 문자열부분을 정수로 해석할 수 없어서 그 전 해석한 부분까지만 리턴 해주는것 이다.

> 결론은 0xf 이런거 쓰지말고 제대로 두번째 인수로 몇진법인지 넣어 주자

### 21.4.3 암묵적 전역

```js
var x = 10; // 전역 변수

function foo() {
  //선언하지 않은 식별자에 값을 할당
  y = 20; // window.y = 20;
}

foo();

// 선언하지 않은 식별자 y를 전역에서 참조할 수 있다
console.log(x + y); // 30
```

> 선언하지 않은 y 변수가 암묵적으로 전역객체의 프포퍼티가 되었다.
> 그래서 마치 전역 변수처럼 작동하게 되어버렸다.

- 위 같은 현상을 암묵적 전역(implicit global)이라고 한다.

- y는 변수가 아니므로 호이스팅이 발생하지 않는다.

> [ 예제 21-38 ]

- 또한 y는 delete 연산자로 삭제할 수 있다. var로 선언한 전역변수도 프로퍼티로 추가되지만 변수기 때문에 delete로 삭제할 수 없다.

> 【예제 21-39 】
