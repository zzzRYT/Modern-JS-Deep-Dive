# 실행 컨텍스트

## 소스코드 타입

1. 전역 코드
2. 함수 코드
3. eval 코드
4. 모듈 코드

## 코드 실행 관리

1. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩된 값의 변화를 지속적으로 관리할 수 있어야 한다.)

2. 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.

3. 현재 실행중인 코드의 실행순서를 변경(예를 들어, 함수 호출에 ㅡ이한 실행 순서 변경)할 수 있어야 하며, 다시 되돌아갈 수 있어야 한다.

- 실행 컨텍스트
  > 소스코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역

자바스크립트 엔진은 먼저 전역 실행 컨텍스트를 생성하고, 함수가 호출되면 코드를 평가하여 함수 실행 컨텍스트를 생성합니다.

이때 생성된 실행 컨텍스트는 스택 자료구조로 관리됩니다. 이를 `실행 컨텍스트 스택`이라고 부릅니다.

## 렉시컬 환경

식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트 입니다.

실행컨텍스트는 LexicalEnvironment 컴포넌트와 VariableEnvironment컴포넌트 나눠지는데

- 환경 레코드

  > 식별자 등록 및 바인딩 값 관리 저장소

- 외부 렉시컬 환경에 대한 참조
  > 상위 스코프를 가리킴.

## 전역 코드 평가

1. 전역 실행 컨텍스트 생성 -> 전역 실행 컨텍스트 (환경 레코드 + 외부 렉시컬 환경 참조)
2. 전역 환경 레코드 생성

- 객체 환경 레코드
  > `전역 객체 생성`에서 생성된 전역 객체에 연결된다. 전역변수, 전역함수가 `BindingObject`를 통해서 전역 객체의 프로퍼티와 메서드가 된다. 그래서 `window`를 통해서 참조가 가능하다.
- 선언적 환경 레코드
  > let, const 키워드로 선언된 전역 변수가 선언적 환경 레코드에 등록되고 관리된다. window객체를 통해서 참조가 불가능하다. 선언문에 도달하기 전까지 `일시적 사각지대`에 빠지게된다. 때문에 그 사이에 참조시 호이스팅은 되지만, 실제로 일시적 사각지대에 빠져있기 때문에 레퍼런스 에러가 발생하는 것 이다.

3. this 바인딩

[[GlobalThisValue]] 내부 슬롯에 this가 바인딩 되고, [[GlobalThisValue]] 내부 슬롯에는 전역 객체가 바인딩되고, 때문에 this를 통해서 전역 객체에 접근이 가능해진다.

4. 외부 렉시컬 환경에 대한 참조 결정

- 최종 전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 null이 할당되고, 이는 전역 렉시컬 환경이 스코프 체인의 종점에 존재함을 의미함

5. 전역 코드 실행

- 어떤 스코프에서 참조하는지 결정하는 식별자가 필요 -> `식별자 결정`
  실행중인 실행 컨텍스트의 렉시컬 환경에서 찾을 수 없다면, 전역 렉시컬 환경에 의해서 상위 스코프를 이동해 식별자를 탐색한다.

```js
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}
foo(20);
```

foo()함수의 참조 렉시컬 스코프는 전역 스코프이다.

전역에서와 마찬가지로 동일하게 흘러감

일련의 흐름만 파악하면 될 듯

1. 함수 실행 컨텍스트 실행 -> 내부에 함수 렉시컬 환경을 생성하고, 그걸 바라봄
2. 함수 렉시컬 환경 동일하게

- 환경 레코드 (이건 this === window를 가르킴)
- 외부 렉시컬 환경 참조 (이건 상위 스코프)

> 렉시컬 스코프는 "함수를 어디서 호출했는지가 아니라 어디에서 정의했는지에 따라서 스코프를 결정"한다.

자바 스크립트 엔진은 함수 정의를 평가하여 객체를 생성할 때, 상위 스코프에 함수 객체를 내부 슬롯 `[[Environment]]`에 저장한다.

즉, 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는, 결국 내부에 저장된 `[[Environment]]`를 참조한 것이다.

이제 `bar()`호출 직전이다. `bar()`가 호출되면 제어권이 넘어가면서, foo() 환경이 생긴 일련의 과정을 동일하게 반복한다.

- 실행이 끝난 함수는 실행 컨텍스트 스택에서 pop되어 제거되고 실행중이던 foo함수가 다시 실행 컨텍스트가 된다. 전역 까지 도달해 코드가 실행이 종료되면 실행 컨텍스트 스택에 아무것도 남지 않는다.
