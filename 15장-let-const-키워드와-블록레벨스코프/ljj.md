# let, const 키워드와 블록 레벨 스코프

## var키워드의 문제점

var 키워드는 오로지 함수 코드 블록만 지역 변수로 인정합니다.

```js
var x = 1;

if (true) {
    var x = 10;
}

console.log(x); // 10
```

var가 두 번 선언이 되면, 두 번째 선언된 var는 자바스크립트 엔진에 의해서 없는 것 처럼 동작하는 원칙 때문에 10이 재할당 되면서 10 이 찍힙니다.

## let 키워드 호이스팅

```js
console.log(foo); //ReferenceError

let foo = 10;

console.log(foo); // 10
```

그냥 얼핏 보기에는 let 키워드를 사용해서 변수를 선언하는 것은 호이스팅이 되지 않는 것 처럼 보입니다.

```js
let foo = 1;

{
    console.log(foo); // ReferenceError
    let foo = 2;
}
```

만약 let이 호이스팅이 되지 않는다면, 위 코드에서 콘솔을 통해서 1이 찍혀야 합니다.
하지만 let은 호이스팅이 진행되기 때문에 스코프 내에서 foo라는 변수가 호이스팅 되었지만, 초기화가 진행되지 않았기 때문에 레퍼런스 에러를 발생시킵니다.

Reference Error를 발생시킬 수 있는 이유는 자바스크립트 엔진에서 let을 평가할 때, 초기화가 되기 전에 호출이 되었다면, ReferenceError를 발생시킵니다. 이 구간을 일시적 사각지대 TDZ라고 부릅니다.

## 전역 객체와 let

var 키워드로 선언된 전역 변수, 함수는 암묵적으로 전역 객체 window의 프로퍼티가 된다는 것을 14장에 전역 객체에 대해서 알아보면서 봤는데, 그렇기 때문에 var키워드는 window객체로 접근이 가능합니다.

```js
var x = 1;

console.log(window.x); // 1
```

하지만 let 키워드로 선언된 전역 변수는 window객체의 프로퍼티가 아닙니다. 때문에 `window.x`와 같은 형태로 접근이 불가능합니다.

let 전역 변수는 보이지 않는 개념적인 블록 (전역 렉시컬 환경의 선언적 환경 레코드 - 실행 컨텍스트)내에 존재합니다.
