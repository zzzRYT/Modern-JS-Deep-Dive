# 42장 비동기 프로그래밍

## 42.1 동기 처리와 비동기 처리

우리가 23장 실행컨텍스트에서 살펴봤듯

| 함수호출 -> 함수코드 평가 -> 함수 실행컨텍스트 생성 -> 실행 컨텍스트 스택(콜스택)에 푸시

위 작업이 일어난다.

함수 코드의 실행이 종료하면 함수 실행 컨텍스트는 스택에서 팝되어 제거된다.

> 예제 42-1

#### 단일 스택

- 자바스크립트의 엔진은 단 하나의 실행 컨택스트 스택을 가진다.

#### tesk

- 실행 컨택스트의 최상위 요소인 "실행 중인 실행 컨텍스트" 를 제외한 모든 실행컨텍스트는 대기중인 태스크(task)들 이다.

#### single thread

- 이처럼 js엔진은 한번에 하나의 태스크만 실행할 수 있는 싱글스레드(single thread)방식으로 동작한다.

#### blocking(작업 중단)

- 싱글 스레드 방식은 한번에 하나의 태스크만 실행하기 때문에 처리에 시간이 걸리는 태스크를 실행하면 블로킹이 발생한다.

> 예제 42-2

#### 동기 synchronous 처리

- 이처럼 실행중인 태스크가 종료할 때 까지 다음 실행될 태스크가 대기하는 방식을 동기처리라고 한다.
- 하나씩 처리하므로 실행순서가 보장되는 장점, 앞 테스크가 종료될 때 까지 뒤 태스크가 블로킹되는 단점

> 예제 42-3
> 위 setTimeout은 42-2의 sleep과 유사하지만 bar()를 블로킹하지 않고 바로 실행한다.

### 비동기 asynchronous 처리

- 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기 처리라고 한다.

## 42.2 이벤트 루프와 태스크 큐

js 특징은 싱글스레드 동작이다. 하지만 블라우저는 많은 태스크가 동시에 처리되는 것처럼 느껴진다.

1. HTML요소 이벤트처리
2. HTTP 요청으로 서버로부터 데이터를 가져와 렌더링
   등등

#### event loop

- js의 동시성(concurrency)을 지원하는것이 바로 이벤트 루프다.
- 이벤트 루프는 브라우저에 내장되어있는 기능이다. (node도)

> 그림 42-4

구글의 V8 자바스크립트 엔진을 비롯한 대부분 js엔진은 크게 2개 영역으로 구분한다.

#### 콜 스택 call stack

- 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행컨텍스트 스택

#### 힙 heap

- 객체가 저장되는 메모리 공간. 실행 컨텍스트는 힙에 저장된 객체를 참조한다.
- 값 저장을 위해서는 메모리 공간 크기를 결정해야 하는데, 객체는 크기가 정해져 있지 않고 런타임에 결정(동적할당)하기 위해 구조화 되어있지 않는 특징이 있다.

---

- 비동기 처리에서 소스평가와 실행을 제외한 모든 처리는 js엔진을 구동하는 환경(브라우저, node.js)이 담당한다.
- 예를 들어 setTimeout의 평가와 실행은 js엔진이 하지만 호출 스케쥴링을 위한 타이머 설정, 콜백 함수 등록은 브라우저가 한다.

- 이를 위해 환경은 아래 2개를 제공한다.

#### 태스크 큐

- setTimeout 이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다.
- 태스크 큐와 별도로, 프로미스의 후속처리 메서드의 콜백함수가 일시적으로 보관되는 마이크로 태스크 큐도 있다. (45.7장)

#### 이벤트 루프

- 이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨택스트가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인한다.
- 콜스택이 비었고, 태스크큐에 함수가 있다면 FIFO로 태스크큐의 대기 함수를 콜스택으로 보낸다.

---

- 예제 탐구해보기

> 예제 42-4

1. 전역 코드가 평가됨. 전역 실행컨텍스트 생성, 콜 스택에 푸시

2. 전역 코드가 실행됨. setTimeout이 호출. setTimeout의 함수 실행 컨텍스트가 생성되고 콜스택에 푸시되어 현재 실행중인 실행컨텍스트가 된다.

3. setTimeout 함수가 실행됨. 인자로 받은 콜백함수(foo)를 호출 스케일링(0초지연:4ms됨을 브라우저한테 알리기)하고 종료된다. 콜스택에서 팝된다.

4. 아래 두 작업이 병행 처리 된다.

- 브라우저: 타이머를 설정하고 타이머 만료를 기다린다. 만료가 되면 콜백함수(foo)가 태스크 큐에 푸시된다.

  > 이때 타이머만료(4ms)가 지나도 테스크큐에서 기다리기 때문에 실제 0초기다리기(4ms) 보다 더 시간이 걸릴 수 있다.

- bar함수가 호출되여 bar의 함수 실행 컨텍스트가 생성되고 콜스택에 푸시되어 현재 실행중인 컨택스트가 된다. bar가 종료되면 후 콜스택에서 팝된다.

5. 전역 코드 실행이 종료되고 전역실행 컨택스트가 콜스택에서 팝된다. 이제 콜 스택에는 아무 실행 컨텍스트도 없다.

6. 이벤트루프가 콜 스택이 비어있는걸 감지하게 되고, 테스크큐에서 대기중인 콜백함수(foo)의 함수 실행 컨텍스트를 콜스택에 푸시한다. 이후 foo가 종료되고 콜스택에서 팝된다.

> 몰랐던점은 전역실행 컨텍스트는 사라지지 않을줄 알았는데 그것마저 비우고 콜백의 함수실행 컨텍스트를 실행시킨다고 함.
> 그럼 콜백은 어디에 참조 되어있나 싶은데, 전역렉시컬환경(전역스코프)은 힙에 남아있기 때문에 거기에 연결된다고함
> 요기서 스코프가 힙에 저장되는 자료구조인것도 알게됨

---

이처럼 비동기 함수인 setTimeout의 콜백 함수는 아래 처럼 작동된다.

> 테크스큐에 푸시 -> 대기 -> 콜스택이 비게 됨(호출함수가 모두 종료) -> 콜스택에 푸시 -> 실행

- js는 싱글 스레드 방식으로 동작하나 이건 브라우저 내장된 js엔진이 싱글 스레드 인것 이다.

- js엔진은 싱글 스레드로 동작하지만 브라우저는 멀티스레드로 동작한다.
